# PriceFetcher

Deterministic background process for fetching product prices using extraction patterns. No AI - purely pattern execution and data storage.

## Features

- **Pattern-based extraction**: Uses patterns generated by ExtractorPatternAgent
- **Multiple extraction methods**: CSS selectors, XPath, JSON-LD, meta tags
- **Fallback support**: Tries multiple methods until one succeeds
- **Validation**: Ensures extracted data quality before storing
- **Rate limiting**: Respects domain-specific request limits
- **Retry logic**: Handles network errors with exponential backoff
- **Structured logging**: JSON logs for easy monitoring
- **Shared database**: Works with Django SQLite database

## Architecture

```
┌─────────────────────────────────────┐
│  Cron Job (every 15 min)            │
└──────────────┬──────────────────────┘
               ↓
┌──────────────────────────────────────┐
│  PriceFetcher                        │
│  1. Load patterns from DB            │
│  2. Get products due for checking    │
│  3. Fetch HTML                       │
│  4. Apply patterns                   │
│  5. Validate extractions             │
│  6. Store prices                     │
└──────────────┬───────────────────────┘
               ↓
┌──────────────────────────────────────┐
│  Shared SQLite Database              │
│  - app_product                       │
│  - app_pricehistory                  │
│  - app_pattern                       │
│  - app_fetchlog                      │
└──────────────────────────────────────┘
```

## Installation

### Using uv (recommended)

```bash
# Install uv package manager
curl -LsSf https://astral.sh/uv/install.sh | sh

# No additional setup needed - dependencies will be installed on first run
```

### Using pip

```bash
# Install dependencies
pip install -r requirements.txt
```

## Usage

### Manual Execution

```bash
# Fetch all products due for checking
uv run scripts/run_fetch.py

# Enable debug logging
uv run scripts/run_fetch.py --verbose

# Output as JSON
uv run scripts/run_fetch.py --json

# Use custom database path
uv run scripts/run_fetch.py --db-path /path/to/db.sqlite3

# Use custom config
uv run scripts/run_fetch.py --config /path/to/config.yaml
```

### Automated Execution (Cron)

```bash
# Setup cron jobs
./scripts/setup_cron.sh

# View cron jobs
crontab -l

# Edit cron jobs
crontab -e
```

The default cron schedule:
- Every 15 minutes: Fetch all products due for checking
- Daily at 2am: Cleanup old log files

### Docker

```bash
# Build image
docker build -t pricefetcher .

# Run manually
docker run --rm -v $(pwd)/../db.sqlite3:/app/db.sqlite3 pricefetcher

# Run as cron job (use docker-compose)
docker-compose up -d
```

## Configuration

Edit `config/settings.yaml`:

```yaml
fetcher:
  request_delay: 2.0      # Delay between requests (seconds)
  timeout: 30.0           # HTTP timeout (seconds)
  max_retries: 3          # Retry attempts

validation:
  min_confidence: 0.6     # Minimum confidence threshold
  max_price_change_pct: 50.0  # Warning threshold for price changes

rate_limits:
  domains:
    amazon.com: 1.0       # Requests per second
    ebay.com: 0.67
```

Environment variables (override config):
- `DATABASE_PATH`: Path to SQLite database
- `LOG_LEVEL`: Logging level (DEBUG, INFO, WARNING, ERROR)
- `MIN_CONFIDENCE`: Minimum confidence threshold

## Components

### Core Modules

- **`fetcher.py`**: Main orchestrator
  - Loads products due for checking
  - Fetches HTML
  - Coordinates extraction and validation
  - Stores results

- **`extractor.py`**: Pattern application
  - Applies CSS, XPath, JSON-LD, meta tag selectors
  - Fallback chain support
  - Extracts price, title, availability, image

- **`validator.py`**: Data validation
  - Validates price format and sanity
  - Checks for suspicious changes
  - Calculates confidence scores

- **`pattern_loader.py`**: Pattern management
  - Loads patterns from database
  - Parses pattern JSON structure

- **`storage.py`**: Database layer
  - Stores price history
  - Logs fetch attempts
  - Updates pattern statistics

### Data Flow

```
1. Celery Beat triggers fetch_prices_by_aggregated_priority every 5 minutes
2. PriorityAggregationService determines which products are due for checking
3. For each product listing:
   a. Load pattern from app_pattern for the store domain
   b. Fetch HTML (with rate limiting)
   c. Apply pattern (CSS → XPath → JSON-LD → meta)
   d. Validate extraction
   e. Store in app_pricehistory
   f. Log in app_fetchlog
   g. Update app_productlisting.last_checked
```

## Database Schema

Uses Django-created tables (see WebUI/app/models.py):

- **`app_product`**: Normalized product entities
- **`app_store`**: Store/retailer information
- **`app_productlisting`**: Product listings per store (URLs, prices)
- **`app_pricehistory`**: Historical prices per listing
- **`app_pattern`**: Extraction patterns per domain
- **`app_fetchlog`**: Fetch success/failure logs per listing

## Logging

Structured JSON logs with:
- Timestamp (ISO format)
- Log level
- Event name
- Contextual data

Example log entry:
```json
{
  "timestamp": "2025-12-14T10:30:00Z",
  "level": "info",
  "event": "product_fetch_completed",
  "product_id": "123e4567-e89b-12d3-a456-426614174000",
  "success": true,
  "price": "29.99",
  "confidence": 0.95,
  "duration_ms": 1234
}
```

## Monitoring

Key metrics to track:
- Fetch success rate (%)
- Average confidence score
- Latency per domain (ms)
- Pattern effectiveness
- Failed extractions by domain

Export logs to monitoring system (e.g., Prometheus, Grafana, DataDog).

## Error Handling

### Common Errors

1. **Pattern not found**
   - Trigger ExtractorPatternAgent to generate pattern
   - Products marked as failed until pattern created

2. **HTTP errors**
   - 4xx: Don't retry (bad URL, not found)
   - 5xx: Retry with exponential backoff
   - Timeouts: Retry up to max_retries

3. **Extraction failures**
   - Try fallback methods
   - Log failure
   - Update pattern statistics
   - Trigger pattern regeneration after 3 consecutive failures

4. **Validation failures**
   - Price not found / invalid format
   - Confidence below threshold
   - Logged but not stored

## Development

### Project Structure

```
PriceFetcher/
├── src/
│   ├── __init__.py
│   ├── fetcher.py        # Main orchestrator
│   ├── extractor.py      # Pattern application
│   ├── validator.py      # Data validation
│   ├── pattern_loader.py # Pattern loading
│   ├── storage.py        # Database layer
│   └── models.py         # Pydantic models
├── config/
│   ├── __init__.py
│   └── settings.yaml     # Configuration
├── scripts/
│   ├── run_fetch.py      # Manual execution
│   └── setup_cron.sh     # Cron setup
├── tests/
│   └── (test files)
├── logs/
│   └── (log files)
├── pyproject.toml        # Package config
└── README.md
```

### Running Tests

```bash
# Install dev dependencies
pip install -e ".[dev]"

# Run tests
pytest

# Run with coverage
pytest --cov=src
```

### Code Quality

```bash
# Format code
ruff format .

# Lint code
ruff check .

# Type checking
mypy src/
```

## Deployment

Run with Docker Compose from the project root:

```bash
cd ..
docker-compose up -d
```

The PriceFetcher runs as part of the Celery worker service. See `docker-compose.yml` for configuration.

## Troubleshooting

### Database not found

```
Error: Database not found at ../db.sqlite3
```

**Solution**: Run Django migrations first:
```bash
cd ../WebUI
python manage.py migrate
```

### Pattern not found for domain

```
Warning: No pattern found for domain amazon.com
```

**Solution**: Trigger ExtractorPatternAgent:
```bash
cd ../ExtractorPatternAgent
uv run scripts/generate_pattern.py https://amazon.com/product-url
```

### Low confidence scores

```
Warning: Confidence 0.45 below threshold 0.6
```

**Solution**:
1. Check if website structure changed
2. Regenerate pattern with ExtractorPatternAgent
3. Adjust `min_confidence` threshold in config

### Rate limiting / IP blocks

```
Error: HTTP 429 Too Many Requests
```

**Solution**:
1. Increase `request_delay` in config
2. Use proxy rotation (future feature)
3. Reduce fetch frequency per domain

## License

See repository LICENSE file.

## Contributing

1. Follow existing code style
2. Add tests for new features
3. Update documentation
4. Use structured logging
5. Handle errors gracefully
